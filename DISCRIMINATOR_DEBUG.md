# ORE Automate Instruction Discriminator - FIXED

## Problem
Getting `0x65` error (InstructionFallbackNotFound) when trying to call the `Automate` instruction.

## Root Cause
We were using **8-byte Anchor-style discriminators** when steel framework uses **1-byte enum value discriminators**.

## Solution

### Key Findings

From [ORE instruction.rs](https://raw.githubusercontent.com/regolith-labs/ore/master/api/src/instruction.rs):
- Enum is `#[repr(u8)]` with `Automate = 0`
- `instruction!(OreInstruction, Automate);` macro generates discriminator

From [ORE SDK](https://raw.githubusercontent.com/regolith-labs/ore/master/api/src/sdk.rs):
```rust
pub fn automate(...) -> Instruction {
    ...
    data: Automate {
        amount: amount.to_le_bytes(),
        deposit: deposit.to_le_bytes(),
        fee: fee.to_le_bytes(),
        mask: mask.to_le_bytes(),
        strategy: strategy as u8,
    }
    .to_bytes(),
}
```

The `.to_bytes()` method generated by `instruction!` macro prepends the **enum value as a 1-byte discriminator**, not an 8-byte Anchor-style hash.

### Correct Format

**Automate Instruction:**
- Discriminator: `0x00` (1 byte - enum value `Automate = 0`)
- amount: 8 bytes (u64, little-endian)
- deposit: 8 bytes (u64, little-endian)
- fee: 8 bytes (u64, little-endian)
- mask: 8 bytes (u64, little-endian)
- strategy: 1 byte (u8)
- **Total: 34 bytes** (not 41 bytes!)

**ClaimSOL Instruction:**
- Discriminator: `0x03` (1 byte - enum value `ClaimSOL = 3`)
- (struct is empty)
- **Total: 1 byte** (not 8 bytes!)

### Changes Made

1. Updated `oreDiscriminators.ts`:
   - `AUTOMATE`: Changed from 8-byte hash to `[0x00]` (1 byte)
   - `CLAIM_SOL`: Changed from 8-byte hash to `[0x03]` (1 byte)

2. Updated `oreProgram.ts`:
   - Fixed instruction data to use 1-byte discriminators
   - Updated comments to reflect correct format

## Testing
This should now work correctly. The instruction data format matches what steel framework expects.
